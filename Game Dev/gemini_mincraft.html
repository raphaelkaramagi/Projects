<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Voxel Engine</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-300 */
            overflow: hidden; /* Prevent scrollbars from Three.js canvas */
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(45, 55, 72, 0.9); /* Tailwind gray-700 with opacity */
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            color: #e2e8f0; /* Tailwind gray-300 */
        }
        #controls h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
        }
        #controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.875rem; /* text-sm */
        }
        #controls select, #controls button {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            border: 1px solid #4a5568; /* Tailwind gray-600 */
            background-color: #2d3748; /* Tailwind gray-700 */
            color: #e2e8f0; /* Tailwind gray-300 */
            font-size: 0.875rem; /* text-sm */
            cursor: pointer;
        }
        #controls button:hover {
            background-color: #4a5568; /* Tailwind gray-600 */
        }
        #messageBox {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(26, 32, 44, 0.9); /* Tailwind gray-900 with opacity */
            color: #a0aec0; /* Tailwind gray-500 */
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            font-size: 0.875rem; /* text-sm */
            display: none; /* Hidden by default */
            z-index: 1000;
        }
        /* Ensure canvas is not focusable to prevent outline on click */
        canvas:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h2>Controls</h2>
        <p class="text-xs mb-2">Left-click: Remove Block</p>
        <p class="text-xs mb-4">Right-click: Place Block</p>
        <label for="blockType">Block Type to Place:</label>
        <select id="blockType">
            <option value="GRASS">Grass</option>
            <option value="DIRT">Dirt</option>
            <option value="STONE">Stone</option>
            <option value="WOOD">Wood</option>
            <option value="LEAVES">Leaves</option>
        </select>
        <p class="text-xs mt-4">Use mouse to orbit camera.</p>
        <p class="text-xs">Scroll to zoom.</p>
    </div>

    <div id="messageBox"></div>

    <script type="module">
        // --- Three.js Global Imports (available after script load) ---
        // const THREE = window.THREE; // Not strictly necessary with type="module" for modern browsers, but good for clarity.

        // --- Configuration ---
        const WORLD_SIZE = { x: 16, y: 8, z: 16 }; // Dimensions of the world in blocks
        const BLOCK_SIZE = 1; // Size of each block in 3D units

        // --- Block Definitions ---
        const BLOCK_TYPES = {
            EMPTY: 0, // Represents an empty space
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
        };

        const BLOCK_COLORS = {
            [BLOCK_TYPES.GRASS]: 0x559944,  // Green
            [BLOCK_TYPES.DIRT]:  0x8B4513,  // Brown (SaddleBrown)
            [BLOCK_TYPES.STONE]: 0x808080,  // Gray
            [BLOCK_TYPES.WOOD]:  0xA0522D,  // Sienna
            [BLOCK_TYPES.LEAVES]:0x228B22,  // ForestGreen
        };

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let worldData = []; // 3D array to store block types
        let blockObjects = {}; // Store references to THREE.Mesh objects by their "x_y_z" key
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let currentPlaceBlockType = BLOCK_TYPES.GRASS;
        const messageBox = document.getElementById('messageBox');
        let messageTimeout;

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(WORLD_SIZE.x / 2, WORLD_SIZE.y * 1.5, WORLD_SIZE.z * 1.5);
            camera.lookAt(WORLD_SIZE.x / 2, 0, WORLD_SIZE.z / 2);

            // Renderer
            const container = document.getElementById('container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true; // Optional: for shadows
            scene.add(directionalLight);

            // Initialize World Data
            initializeWorldData();

            // Create Initial World Geometry
            createWorldGeometry();

            // Controls (OrbitControls for camera manipulation)
            // OrbitControls is not part of the core Three.js, needs to be imported or included.
            // For simplicity, we'll implement basic mouse look later or rely on user to add OrbitControls if they have it.
            // For now, a static camera or very simple mouse pan/zoom.
            // Let's use a simple custom orbit control logic for this example.
            setupBasicOrbitControls();


            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            document.getElementById('blockType').addEventListener('change', (event) => {
                currentPlaceBlockType = BLOCK_TYPES[event.target.value];
            });

            animate();
        }

        function initializeWorldData() {
            for (let x = 0; x < WORLD_SIZE.x; x++) {
                worldData[x] = [];
                for (let y = 0; y < WORLD_SIZE.y; y++) {
                    worldData[x][y] = [];
                    for (let z = 0; z < WORLD_SIZE.z; z++) {
                        if (y < WORLD_SIZE.y / 2 - 1) {
                            worldData[x][y][z] = BLOCK_TYPES.STONE;
                        } else if (y < WORLD_SIZE.y / 2) {
                            worldData[x][y][z] = BLOCK_TYPES.DIRT;
                        } else if (y === Math.floor(WORLD_SIZE.y / 2) ) {
                             worldData[x][y][z] = BLOCK_TYPES.GRASS;
                        }
                        else {
                            worldData[x][y][z] = BLOCK_TYPES.EMPTY;
                        }
                    }
                }
            }
        }

        function createWorldGeometry() {
            // Clear existing blocks from scene and map
            for (const key in blockObjects) {
                scene.remove(blockObjects[key]);
                delete blockObjects[key];
            }

            const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

            for (let x = 0; x < WORLD_SIZE.x; x++) {
                for (let y = 0; y < WORLD_SIZE.y; y++) {
                    for (let z = 0; z < WORLD_SIZE.z; z++) {
                        const blockType = worldData[x][y][z];
                        if (blockType !== BLOCK_TYPES.EMPTY) {
                            addBlockToScene(x, y, z, blockType, blockGeometry);
                        }
                    }
                }
            }
        }

        function addBlockToScene(x, y, z, blockType, geometry = null) {
            if (!geometry) {
                geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
            const material = new THREE.MeshLambertMaterial({ color: BLOCK_COLORS[blockType] });
            const block = new THREE.Mesh(geometry, material);
            block.position.set(
                x * BLOCK_SIZE - (WORLD_SIZE.x * BLOCK_SIZE) / 2 + BLOCK_SIZE / 2,
                y * BLOCK_SIZE - (WORLD_SIZE.y * BLOCK_SIZE) / 2 + BLOCK_SIZE / 2,
                z * BLOCK_SIZE - (WORLD_SIZE.z * BLOCK_SIZE) / 2 + BLOCK_SIZE / 2
            );
            block.userData = { x, y, z, type: blockType }; // Store world coordinates

            const key = `${x}_${y}_${z}`;
            scene.add(block);
            blockObjects[key] = block;
        }

        function removeBlockFromScene(x, y, z) {
            const key = `${x}_${y}_${z}`;
            if (blockObjects[key]) {
                scene.remove(blockObjects[key]);
                blockObjects[key].geometry.dispose(); // Dispose geometry
                blockObjects[key].material.dispose(); // Dispose material
                delete blockObjects[key];
                worldData[x][y][z] = BLOCK_TYPES.EMPTY;
                return true;
            }
            return false;
        }


        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(event) {
            // Normalize mouse coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(blockObjects)); // Intersect with our block meshes

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const { x, y, z } = intersectedObject.userData; // World coords from userData

                if (event.button === 0) { // Left click - remove block
                    if (removeBlockFromScene(x, y, z)) {
                        showMessage(`Removed block at (${x}, ${y}, ${z})`);
                    }
                } else if (event.button === 2) { // Right click - place block
                    const normal = intersects[0].face.normal.clone();
                    // Calculate position of the new block based on the face normal
                    const newBlockPos = {
                        x: x + normal.x,
                        y: y + normal.y,
                        z: z + normal.z
                    };

                    // Check bounds
                    if (newBlockPos.x >= 0 && newBlockPos.x < WORLD_SIZE.x &&
                        newBlockPos.y >= 0 && newBlockPos.y < WORLD_SIZE.y &&
                        newBlockPos.z >= 0 && newBlockPos.z < WORLD_SIZE.z) {

                        // Check if the space is empty
                        if (worldData[newBlockPos.x][newBlockPos.y][newBlockPos.z] === BLOCK_TYPES.EMPTY) {
                            worldData[newBlockPos.x][newBlockPos.y][newBlockPos.z] = currentPlaceBlockType;
                            addBlockToScene(newBlockPos.x, newBlockPos.y, newBlockPos.z, currentPlaceBlockType);
                            showMessage(`Placed ${document.getElementById('blockType').options[document.getElementById('blockType').selectedIndex].text} block at (${newBlockPos.x}, ${newBlockPos.y}, ${newBlockPos.z})`);
                        } else {
                            showMessage("Cannot place block: Space occupied.", "error");
                        }
                    } else {
                        showMessage("Cannot place block: Out of world bounds.", "error");
                    }
                }
            }
            // Prevent context menu on right click
            event.preventDefault();
        }

        // --- Basic Orbit Controls (Mouse Drag to Orbit, Scroll to Zoom) ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function setupBasicOrbitControls() {
            renderer.domElement.addEventListener('mousedown', (event) => {
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isDragging) return;

                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                // Calculate rotation angles based on mouse movement
                const yawAngle = (deltaMove.x * 0.005); // Horizontal rotation
                const pitchAngle = (deltaMove.y * 0.005); // Vertical rotation

                // Apply rotations to the camera
                // This is a simplified orbit. A full OrbitControls implementation is more complex.
                // We rotate the camera's position around the scene's center.
                const center = new THREE.Vector3(0,0,0); // Assuming scene is centered at origin for simplicity
                                                        // Or more accurately: new THREE.Vector3(WORLD_SIZE.x * BLOCK_SIZE / 2 - (WORLD_SIZE.x * BLOCK_SIZE) / 2, 0, ... )
                                                        // which simplifies to an offset based on how blocks are positioned.
                                                        // For this example, the blocks are offset so the world center is near (0,0,0) in Three.js coords.

                camera.position.sub(center); // Move camera to origin relative to center

                // Apply yaw (around Y axis)
                const yawQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -yawAngle);
                camera.position.applyQuaternion(yawQuaternion);

                // Apply pitch (around X axis relative to camera)
                // Get camera's local X axis
                const cameraX = new THREE.Vector3().setFromMatrixColumn(camera.matrix, 0);
                const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(cameraX, -pitchAngle);
                camera.position.applyQuaternion(pitchQuaternion);

                camera.position.add(center); // Move camera back
                camera.lookAt(center); // Always look at the center

                previousMousePosition = { x: event.clientX, y: event.clientY };
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            renderer.domElement.addEventListener('mouseout', () => { // Stop dragging if mouse leaves canvas
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (event) => {
                event.preventDefault(); // Prevent page scrolling
                const zoomSpeed = 0.1;
                const direction = event.deltaY > 0 ? 1 : -1; // 1 for zoom out, -1 for zoom in
                const distance = camera.position.length();
                const newDistance = Math.max(BLOCK_SIZE * 3, Math.min(distance + direction * zoomSpeed * distance, 100)); // Min/max zoom
                camera.position.setLength(newDistance);
            }, { passive: false }); // passive: false to allow preventDefault
        }

        // --- Utility Functions ---
        function showMessage(text, type = "info") {
            if (messageTimeout) clearTimeout(messageTimeout);
            messageBox.textContent = text;
            messageBox.style.display = 'block';
            messageBox.style.backgroundColor = type === "error" ? "rgba(191, 54, 54, 0.9)" : "rgba(26, 32, 44, 0.9)"; // Red-700 for error
            messageBox.style.color = type === "error" ? "#fed7d7" : "#a0aec0"; // Red-200 for error

            messageTimeout = setTimeout(() => {
                messageBox.style.display = 'none';
            }, 3000);
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            // Any animations or updates per frame would go here
            // e.g., controls.update() if using THREE.OrbitControls
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>
